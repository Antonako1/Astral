/*+++
Contains shared, non-platform specific code for the ASTRAL library.

For ASTRAL_CON.H
---*/

#include <ASTRAL.H>

/*+++
ASTRAL_CON.H
---*/

/*+++
All border styles are defined as 8 pieces. 4 corners, 4 sides
---*/

/// @brief BORDER_STYLE_SOLID. ASCII border style for solid borders. 
AS_U8 ASCII_BORDER_STYLE_SOLID[PIECES_PER_BORDER] = {
    '/', '-', '\\', 
    '|',      '|', 
    '\\', '-', '/'
};

/// @brief BORDER_STYLE_DASHED. ASCII border style for dashed borders.
AS_U8 ASCII_BORDER_STYLE_DASHED[PIECES_PER_BORDER] = {
    '/', '-', '\\', 
    '|',      '|', 
    '\\', '-', '/'
};


/// @brief BORDER_STYLE_DOTTED. ASCII border style for dotted borders.
AS_U8 ASCII_BORDER_STYLE_DOTTED[PIECES_PER_BORDER] = {
    '/', '.', '\\', 
    ':',      ':', 
    '\\', '.', '/'
};

/// @brief BORDER_STYLE_DOUBLE. ASCII border style for double borders.
AS_U8 ASCII_BORDER_STYLE_DOUBLE[PIECES_PER_BORDER] = {
    '/', '=', '\\', 
    '|',      '|', 
    '\\', '=', '/'
};

#pragma warning(disable: 4066)
#pragma message("§§ ASTRAL_CON: UTF-8 border styles are not yet implemented.")

/// @brief BORDER_STYLE_UTF8_SOLID. UTF-8 border style for solid borders.
AS_WCHAR UTF8_BORDER_STYLE_SOLID[PIECES_PER_BORDER] = {
    L'┌', L'─', L'┐', 
    L'│',      L'│', 
    L'└', L'─', L'┘'
};

/// @brief BORDER_STYLE_UTF8_DASHED. UTF-8 border style for dashed borders.
AS_WCHAR UTF8_BORDER_STYLE_DASHED[PIECES_PER_BORDER] = {
    L'┌', L'┄', L'┐', 
    L'┆',      L'┆', 
    L'└', L'┄', L'┘'
};

/// @brief BORDER_STYLE_UTF8_DOTTED. UTF-8 border style for dotted borders.
AS_WCHAR UTF8_BORDER_STYLE_DOTTED[PIECES_PER_BORDER] = {
    L'┌', L'┉', L'┐', 
    L'┊',      L'┊', 
    L'└', L'┉', L'┘'
};

/// @brief BORDER_STYLE_UTF8_DOUBLE. UTF-8 border style for double borders.
AS_WCHAR UTF8_BORDER_STYLE_DOUBLE[PIECES_PER_BORDER] = {
    L'╔', L'═', L'╗', 
    L'║',      L'║', 
    L'╚', L'═', L'╝'
};


AS_U8 ASCII_BORDER_CUSTOM[PIECES_PER_BORDER] = {
    '/', '-', '\\', 
    '|',      '|', 
    '\\', '-', '/'
};
AS_WCHAR UTF8_BORDER_CUSTOM[PIECES_PER_BORDER] = {
    L'╔', L'═', L'╗', 
    L'║',      L'║', 
    L'╚', L'═', L'╝'
};

#pragma warning(default: 4066)

AS_U0 ASTRAL_CON_SET_CUSTOM_ASCII_BORDER(AS_U8* BORDER_STYLE) {
    for(AS_U64 i = 0; i < PIECES_PER_BORDER; i++) {
        ASCII_BORDER_CUSTOM[i] = BORDER_STYLE[i];
    }
}
AS_U0 ASTRAL_CON_SET_CUSTOM_UTF8_BORDER(AS_WCHAR* BORDER_STYLE) {
    for(AS_U64 i = 0; i < PIECES_PER_BORDER; i++) {
        UTF8_BORDER_CUSTOM[i] = BORDER_STYLE[i];
    }
}

AS_U8 *ASTRAL_CON_GET_CUSTOM_ASCII_BORDER() {
    return ASCII_BORDER_CUSTOM;
}

AS_WCHAR *ASTRAL_CON_GET_CUSTOM_UTF8_BORDER() {
    return UTF8_BORDER_CUSTOM;
}

AS_BOOLEAN ASTRAL_CON_IS_RUNNING(ASTRAL_CONSOLE* CONSOLE) {
    return CONSOLE->RUNNING;
}

AS_U0 ASTRAL_CON_SET_COLOUR_F(ASTRAL_CON_COLOUR* COLOUR, AS_U32 FOREGROUND){
    COLOUR->FOREGROUND = FOREGROUND;
}
AS_U0 ASTRAL_CON_SET_COLOUR_B(ASTRAL_CON_COLOUR* COLOUR, AS_U32 BACKGROUND){
    COLOUR->BACKGROUND = BACKGROUND;
}
ASTRAL_CON_COLOUR ASTRAL_CON_CREATE_COLOUR_F_B(AS_U32 FOREGROUND, AS_U32 BACKGROUND){
    ASTRAL_CON_COLOUR COLOUR = {
        FOREGROUND,
        BACKGROUND
    };
    return COLOUR;
}

ASTRAL_CON_MARGIN ASTRAL_CON_CREATE_MARGIN(AS_U64 TOP, AS_U64 BOTTOM, AS_U64 LEFT, AS_U64 RIGHT) {
    ASTRAL_CON_MARGIN MARGIN = {
        TOP,
        BOTTOM,
        LEFT,
        RIGHT
    };
    return MARGIN;
}
ASTRAL_CON_PADDING ASTRAL_CON_CREATE_PADDING(AS_U64 TOP, AS_U64 BOTTOM, AS_U64 LEFT, AS_U64 RIGHT) {
    ASTRAL_CON_PADDING PADDING = {
        TOP,
        BOTTOM,
        LEFT,
        RIGHT
    };
    return PADDING;
}

// TODO: 
ASTRAL_CON_STYLING ASTRAL_CON_CREATE_STYLING_WITH_PREDEF_STYLING(AS_U32 TYPE_COMBO, AS_U32 CATEGORY){
    AS_U32 TYPE = TYPE_COMBO >> 16;
    AS_U32 SUB_TYPE = TYPE_COMBO & 0xFFFF;
    ASTRAL_CON_STYLING STYLING = {
        ASTRAL_CON_NULL_COLOUR,
        ASTRAL_CON_NULL_MARGIN,
        ASTRAL_CON_NULL_PADDING,
        0, 0, ASTRAL_CON_NULL_COLOUR, BORDER_STYLE_DEFAULT,
        ASTRAL_CON_CREATE_SIZE(0, 0)
    };
    switch(TYPE){
        case ASTRAL_CON_UI_ELEM_TYPE_BUTTON:{
            switch(SUB_TYPE) {
                case ASTRAL_CON_BUTTON_TYPE_TEXT: {} break;
                case ASTRAL_CON_BUTTON_TYPE_RADIO: {} break;
                case ASTRAL_CON_BUTTON_TYPE_CHECK: {} break;
                case ASTRAL_CON_BUTTON_TYPE_DROPDOWN: {} break;
                default: {}break;
            }
        } break;
        case ASTRAL_CON_UI_ELEM_TYPE_TEXT:{
            switch(SUB_TYPE) {
                case ASTRAL_CON_TEXT_TYPE_TEXT: {} break;
                case ASTRAL_CON_TEXT_TYPE_TITLE: {} break;
                default: {}break;
            }
        } break;
        case ASTRAL_CON_UI_ELEM_TYPE_BOX:{
            switch(SUB_TYPE) {
                case ASTRAL_CON_BOX_TYPE_VERTICAL: {} break;
                case ASTRAL_CON_BOX_TYPE_HORIZONTAL: {} break;
                default: {}break;
            }
        } break;
    }
}
AS_U0 ASTRAL_CON_SET_PREDEF_STYLING(ASTRAL_CON_UI_ELEM* ELEMENT, AS_U32 CATEGORY){
    ELEMENT->STYLING = ASTRAL_CON_CREATE_STYLING_WITH_PREDEF_STYLING(
        AS_CON_TYPE_COMBO(ELEMENT->TYPE, ELEMENT->SUB_TYPE),
        CATEGORY
    );
}

ASTRAL_CON_UI_ELEM_ARR* ASTRAL_CON_UI_ELEM_ARR_INIT() {
    ASTRAL_CON_UI_ELEM_ARR* RETVAL = (ASTRAL_CON_UI_ELEM_ARR*)ASTRAL_M_ALLOC(sizeof(ASTRAL_CON_UI_ELEM_ARR));
    if(RETVAL == NULLPTR) return NULLPTR;
    RETVAL->SIZE = 0;
    RETVAL->ELEMENTS = NULLPTR;
    return RETVAL;
}   
ASTRAL_CON_UI_ELEM *ASTRAL_CON_UI_ELEM_ARR_PUSH(ASTRAL_CON_UI_ELEM_ARR* ARR, ASTRAL_CON_UI_ELEM* ELEMENT) {
    ARR->SIZE++;
    ARR->ELEMENTS = (ASTRAL_CON_UI_ELEM*)ASTRAL_M_REALLOC(ARR->ELEMENTS, ARR->SIZE * sizeof(ASTRAL_CON_UI_ELEM));
    if(ARR->ELEMENTS == NULLPTR) return NULLPTR;
    ARR->ELEMENTS[ARR->SIZE - 1] = *ELEMENT;
    return &ARR->ELEMENTS[ARR->SIZE - 1];
}
AS_BOOLEAN ASTRAL_CON_UI_ELEM_ARR_POP(ASTRAL_CON_UI_ELEM_ARR* ARR) {
    if(ARR->SIZE == 0) return FALSE;
    ARR->SIZE--;
    ARR->ELEMENTS = (ASTRAL_CON_UI_ELEM*)ASTRAL_M_REALLOC(ARR->ELEMENTS, ARR->SIZE * sizeof(ASTRAL_CON_UI_ELEM));
    if(ARR->ELEMENTS == NULLPTR) return FALSE;
    return TRUE;
}
AS_U0 ASTRAL_CON_UI_ELEM_ARR_FREE(ASTRAL_CON_UI_ELEM_ARR* ARR) {
    if(ARR->SIZE > 0) ASTRAL_M_FREE(ARR->ELEMENTS);
    ASTRAL_M_FREE(ARR);
    ARR->ELEMENTS = NULLPTR;
    ARR->SIZE = 0;
    ARR = NULLPTR;
}

ASTRAL_CON_COORD ASTRAL_CON_CREATE_COORD(AS_U64 X, AS_U64 Y){
    ASTRAL_CON_COORD RETVAL = {
        X, Y
    };
    return RETVAL;
}
ASTRAL_CON_SIZE ASTRAL_CON_CREATE_SIZE(AS_U64 WIDTH, AS_U64 HEIGHT){
    ASTRAL_CON_SIZE RETVAL = {
        WIDTH, HEIGHT
    };
    return RETVAL;
}

ASTRAL_CON_UI_ELEM *ASTRAL_CON_UI_ELEM_INIT(ASTRAL_CON_UI_ELEM* PARENT) {

    // allocate memory for the element
    ASTRAL_CON_UI_ELEM* ELEMENT = (ASTRAL_CON_UI_ELEM*)ASTRAL_M_ALLOC(sizeof(ASTRAL_CON_UI_ELEM));
    if(ELEMENT == NULLPTR) return NULLPTR;

    // push to parent
    ASTRAL_CON_UI_ELEM_ARR_PUSH(PARENT->CHILDREN, ELEMENT);
    
    // set default values for the element
    ELEMENT->TYPE = ASTRAL_CON_UI_ELEM_TYPE_BOX;
    ELEMENT->SUB_TYPE = ASTRAL_DEF_SUB_TYPE;
    ELEMENT->ID = AS_UNUSED_ID;
    ELEMENT->POS.X = 0;
    ELEMENT->POS.Y = 0;
    ASTRAL_CON_SET_PREDEF_STYLING(ELEMENT, 
        ASTRAL_CON_STYLING_CATEGORY_COLOUR |
        ASTRAL_CON_STYLING_CATEGORY_MARGIN |
        ASTRAL_CON_STYLING_CATEGORY_PADDING |
        ASTRAL_CON_STYLING_CATEGORY_BORDER_RADIUS |
        ASTRAL_CON_STYLING_CATEGORY_BORDER_WIDTH |
        ASTRAL_CON_STYLING_CATEGORY_BORDER_COLOUR |
        ASTRAL_CON_STYLING_CATEGORY_BORDER_STYLE |
        ASTRAL_CON_STYLING_CATEGORY_SIZE
    );
    ELEMENT->CHILDREN = NULLPTR;
    ELEMENT->PARENT = PARENT;
    ELEMENT->TEXT = NULLPTR;
    ELEMENT->STATE = 0;
    ELEMENT->SZ = sizeof(ASTRAL_CON_UI_ELEM);
    return ELEMENT;
}
ASTRAL_CON_UI_ELEM *ASTRAL_CON_UI_ELEM_INIT_EX(
    ASTRAL_CON_UI_ELEM *PARENT, 
    AS_U64 TYPE, 
    AS_U64 SUB_TYPE, 
    AS_U64 ID, 
    ASTRAL_CON_COORD POS, 
    ASTRAL_CON_STYLING STYLING, 
    ASTRAL_CON_UI_ELEM_ARR *CHILDREN, 
    ASTRAL_CON_STR_OBJ *TEXT 
) {
    ASTRAL_CON_UI_ELEM* ELEMENT = (ASTRAL_CON_UI_ELEM*)ASTRAL_M_ALLOC(sizeof(ASTRAL_CON_UI_ELEM));
    if(ELEMENT == NULLPTR) return NULLPTR;
    if(TYPE == ASTRAL_CON_UI_ELEM_TYPE_ROOT) {
        ELEMENT->PARENT = NULLPTR;
    } else {
        ELEMENT->PARENT = PARENT;
        ASTRAL_CON_UI_ELEM_ARR_PUSH(PARENT->CHILDREN, ELEMENT);
    }
    ELEMENT->TYPE = TYPE;
    ELEMENT->SUB_TYPE = SUB_TYPE;
    ELEMENT->ID = ID;
    ELEMENT->POS = POS;
    ELEMENT->STYLING = STYLING;
    ELEMENT->CHILDREN = CHILDREN;
    ELEMENT->TEXT = TEXT;
    ELEMENT->STATE = 0;
    ELEMENT->SZ = sizeof(ASTRAL_CON_UI_ELEM);
    return ELEMENT;
}
AS_U0 ASTRAL_CON_UI_ELEM_FREE(ASTRAL_CON_UI_ELEM* ELEMENT) {
    if (ELEMENT == NULLPTR) {
        return;
    }

    if (ELEMENT->CHILDREN != NULLPTR) {
        // Recursively free children
        for (AS_U64 i = 0; i < ELEMENT->CHILDREN->SIZE; i++) {
            ASTRAL_CON_UI_ELEM_FREE(&ELEMENT->CHILDREN->ELEMENTS[i]);
        }

        // Free the children array
        ASTRAL_CON_UI_ELEM_ARR_FREE(ELEMENT->CHILDREN);
        ELEMENT->CHILDREN = NULLPTR;
    }

    // Free text object if present
    if (ELEMENT->TEXT != NULLPTR) {
        ASTRAL_CON_FREE_STR_OBJ(ELEMENT->TEXT);
        ELEMENT->TEXT = NULLPTR;
    }
    
    // Free the element itself
    ASTRAL_M_FREE(ELEMENT);
}

ASTRAL_CON_UI_ELEM* ASTRAL_CON_UI_GET_CHILD_AT_INDEX(ASTRAL_CON_UI_ELEM_ARR* ARR, AS_U64 INDEX) {
    if(INDEX >= ARR->SIZE) return NULLPTR;
    ASTRAL_CON_UI_ELEM *ELEMENT = &ARR->ELEMENTS[INDEX];
    return ELEMENT;
}
AS_U64 ASTRAL_CON_UI_GET_CHILD_OF_ID(ASTRAL_CON_UI_ELEM* ELEMENT, AS_U64 ID, ASTRAL_CON_UI_ELEM* CHILD){
    for(AS_U64 i = 0; i < ELEMENT->CHILDREN->SIZE; i++) {
        if(ELEMENT->CHILDREN->ELEMENTS[i].ID == ID) {
            CHILD = &ELEMENT->CHILDREN->ELEMENTS[i];
            return i;
        }
    }
    return U64_MAX;
}

ASTRAL_CON_STYLING ASTRAL_CON_CREATE_STYLING (
    ASTRAL_CON_COLOUR COLOUR,
    ASTRAL_CON_MARGIN MARGIN,
    ASTRAL_CON_PADDING PADDING,
    AS_U64 BORDER_RADIUS,
    AS_U64 BORDER_WIDTH,
    ASTRAL_CON_COLOUR BORDER_COLOUR,
    AS_U64 BORDER_STYLE,
    ASTRAL_CON_SIZE SIZE
) {
    ASTRAL_CON_STYLING STYLING = {
        COLOUR,
        MARGIN,
        PADDING,
        BORDER_RADIUS,
        BORDER_WIDTH,
        BORDER_COLOUR,
        BORDER_STYLE,
        SIZE
    };
    return STYLING;
}

// TODO:IMPLEMENT
ASTRAL_CON_UI_ELEM* ASTRAL_CON_UI_RECUR_SEARCH_ID(ASTRAL_CON_UI_ELEM* ELEMENT, AS_U64 ID, AS_U32 MAX_DEPTH);

AS_U0 ASTRAL_CON_UI_ELEM_SET_TEXT(ASTRAL_CON_UI_ELEM* ELEMENT, AS_STRING *  TEXT){
    if(ELEMENT->TEXT != NULLPTR) {
        ASTRAL_CON_FREE_STR_OBJ(ELEMENT->TEXT);
    }
    ELEMENT->TEXT = ASTRAL_CON_CREATE_STR_OBJ(TEXT, ASTRAL_CON_STR_POS_CENTER);
}


ASTRAL_CON_STR_OBJ *ASTRAL_CON_CREATE_STR_OBJ(AS_STRING *STRING, AS_U32 STR_POS) {
    ASTRAL_CON_STR_OBJ* STR_OBJ = (ASTRAL_CON_STR_OBJ*)ASTRAL_M_ALLOC(sizeof(ASTRAL_CON_STR_OBJ));
    if(STR_OBJ == NULLPTR) return NULLPTR;
    STR_OBJ->STR_POS = STR_POS;
    STR_OBJ->STRING = ASTRAL_STR_DUPLICATE(STRING);
    if(STR_OBJ->STRING == NULLPTR) return NULLPTR;
    return STR_OBJ;
}
AS_U0 ASTRAL_CON_FREE_STR_OBJ(ASTRAL_CON_STR_OBJ* STR_OBJ) {
    ASTRAL_STR_FREE(STR_OBJ->STRING); //Frees STRING aswell
    ASTRAL_M_FREE(STR_OBJ);
    STR_OBJ = NULLPTR;
}


AS_U0 ASTRAL_CON_BUFFER_INIT(ASTRAL_CON_BUFFER* BUFFER, AS_U64 SIZE) {
    BUFFER->DATA = (AS_U8*)ASTRAL_M_ALLOC(SIZE);
    if(BUFFER->DATA == NULLPTR) return;
    BUFFER->SIZE = SIZE;
}
AS_U0 ASTRAL_CON_BUFFER_DEL(ASTRAL_CON_BUFFER* BUFFER) {
    if(BUFFER->DATA == NULLPTR) return;
    ASTRAL_M_FREE(BUFFER->DATA);
    BUFFER->DATA = NULLPTR;
    BUFFER->SIZE = 0;
}

AS_U0 *ASTRAL_CON_SET_BUFFER_SZ(ASTRAL_CON_BUFFER* BUFFER, AS_U64 SIZE){
    BUFFER->DATA = (AS_U8*)ASTRAL_M_REALLOC(BUFFER->DATA, SIZE);
    if(BUFFER->DATA == NULLPTR) return NULLPTR;
    BUFFER->SIZE = SIZE;
    return BUFFER->DATA;
}

AS_U0 ASTRAL_CON_BUFFER_CLEAR(ASTRAL_CON_BUFFER* BUFFER){
    ASTRAL_M_ZERO(BUFFER->DATA, BUFFER->SIZE);
}
AS_U0 ASTRAL_CON_BUFFER_COPY(ASTRAL_CON_BUFFER* DST, ASTRAL_CON_BUFFER* SRC){
    DST = ASTRAL_CON_BUFFER_COPY2(SRC);
    if(DST == NULLPTR) return;
}
ASTRAL_CON_BUFFER *ASTRAL_CON_BUFFER_COPY2(ASTRAL_CON_BUFFER* SRC){
    ASTRAL_CON_BUFFER *DST = NULLPTR;
    ASTRAL_CON_BUFFER_INIT(DST, SRC->SIZE);
    if(DST == NULLPTR) return NULLPTR;
    ASTRAL_M_COPY(DST->DATA, SRC->DATA, SRC->SIZE);
    DST->SIZE = SRC->SIZE;
    return DST;
}